{"version":3,"sources":["reviewSchema.js"],"names":["mongoose","require","reviewSchema","Schema","review","String","type","rating","Number","min","createdAt","Date","now","tour","ObjectId","ref","user","toJSON","virtuals","Review","model","module","exports"],"mappings":"aAAA,IAAMA,SAAWC,QAAQ,YAGnBC,aAAe,IAAIF,SAASG,OAChC,CADID,OAAAA,CAEFE,KAAQC,OACNC,SADM,EAAA,EAAA,6BADVC,OAAA,CAKEA,KAAQC,OACNF,IAAME,EACNC,IAFM,GALVC,UAAA,CAUEA,KAASC,KACPL,QADSK,KAAAC,KAVbC,KAAA,CAcMP,KAAEN,SAAAG,OAAAW,SACJR,IAAMN,OACNe,SAFI,EAAA,EAAA,kCAdRC,KAAA,CAmBMV,KAAEN,SAAAG,OAAAW,SACJR,IAAMN,OACNe,SAFI,EAAA,EAAA,kCApBW,CA2BjBE,OAAQ,CAAAC,UAAA,GAAEA,SAAU,CAAAA,UAAA,KAqElBC,OAASnB,SAASoB,MAAM,SAAUlB,cAExCmB,OAAOC,QAAUH","file":"reviewSchema.min.js","sourcesContent":["const mongoose = require('mongoose');\n// const Tour = require('./tourModel');\n\nconst reviewSchema = new mongoose.Schema(\n  {\n    review: {\n      type: String,\n      required: [true, 'Review can not be empty!']\n    },\n    rating: {\n      type: Number,\n      min: 1,\n      max: 5\n    },\n    createdAt: {\n      type: Date,\n      default: Date.now\n    },\n    tour: {\n      type: mongoose.Schema.ObjectId,\n      ref: 'Tour',\n      required: [true, 'Review must belong to a tour.']\n    },\n    user: {\n      type: mongoose.Schema.ObjectId,\n      ref: 'User',\n      required: [true, 'Review must belong to a user']\n    }\n  },\n  {\n    toJSON: { virtuals: true },\n    toObject: { virtuals: true }\n  }\n);\n\n// reviewSchema.index({ tour: 1, user: 1 }, { unique: true });\n\n// reviewSchema.pre(/^find/, function(next) {\n//   // this.populate({\n//   //   path: 'tour',\n//   //   select: 'name'\n//   // }).populate({\n//   //   path: 'user',\n//   //   select: 'name photo'\n//   // });\n\n//   this.populate({\n//     path: 'user',\n//     select: 'name photo'\n//   });\n//   next();\n// });\n\n// reviewSchema.statics.calcAverageRatings = async function(tourId) {\n//   const stats = await this.aggregate([\n//     {\n//       $match: { tour: tourId }\n//     },\n//     {\n//       $group: {\n//         _id: '$tour',\n//         nRating: { $sum: 1 },\n//         avgRating: { $avg: '$rating' }\n//       }\n//     }\n//   ]);\n//   // console.log(stats);\n\n//   if (stats.length > 0) {\n//     await Tour.findByIdAndUpdate(tourId, {\n//       ratingsQuantity: stats[0].nRating,\n//       ratingsAverage: stats[0].avgRating\n//     });\n//   } else {\n//     await Tour.findByIdAndUpdate(tourId, {\n//       ratingsQuantity: 0,\n//       ratingsAverage: 4.5\n//     });\n//   }\n// };\n\n// reviewSchema.post('save', function() {\n//   // this points to current review\n//   this.constructor.calcAverageRatings(this.tour);\n// });\n\n// // findByIdAndUpdate\n// // findByIdAndDelete\n// reviewSchema.pre(/^findOneAnd/, async function(next) {\n//   this.r = await this.findOne();\n//   // console.log(this.r);\n//   next();\n// });\n\n// reviewSchema.post(/^findOneAnd/, async function() {\n//   // await this.findOne(); does NOT work here, query has already executed\n//   await this.r.constructor.calcAverageRatings(this.r.tour);\n// });\n\nconst Review = mongoose.model('Review', reviewSchema);\n\nmodule.exports = Review;\n"]}