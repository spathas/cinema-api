{"version":3,"sources":["reviewSchema.js"],"names":["mongoose","require","reviewSchema","Schema","review","type","String","required","rating","Number","min","max","createdAt","Date","now","tour","ObjectId","ref","user","toJSON","virtuals","toObject","Review","model","module","exports"],"mappings":";;AAAA,IAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB,C,CACA;;;AAEA,IAAMC,YAAY,GAAG,IAAIF,QAAQ,CAACG,MAAb,CACnB;AACEC,EAAAA,MAAM,EAAE;AACNC,IAAAA,IAAI,EAAEC,MADA;AAENC,IAAAA,QAAQ,EAAE,CAAC,IAAD,EAAO,0BAAP;AAFJ,GADV;AAKEC,EAAAA,MAAM,EAAE;AACNH,IAAAA,IAAI,EAAEI,MADA;AAENC,IAAAA,GAAG,EAAE,CAFC;AAGNC,IAAAA,GAAG,EAAE;AAHC,GALV;AAUEC,EAAAA,SAAS,EAAE;AACTP,IAAAA,IAAI,EAAEQ,IADG;AAET,eAASA,IAAI,CAACC;AAFL,GAVb;AAcEC,EAAAA,IAAI,EAAE;AACJV,IAAAA,IAAI,EAAEL,QAAQ,CAACG,MAAT,CAAgBa,QADlB;AAEJC,IAAAA,GAAG,EAAE,MAFD;AAGJV,IAAAA,QAAQ,EAAE,CAAC,IAAD,EAAO,+BAAP;AAHN,GAdR;AAmBEW,EAAAA,IAAI,EAAE;AACJb,IAAAA,IAAI,EAAEL,QAAQ,CAACG,MAAT,CAAgBa,QADlB;AAEJC,IAAAA,GAAG,EAAE,MAFD;AAGJV,IAAAA,QAAQ,EAAE,CAAC,IAAD,EAAO,8BAAP;AAHN;AAnBR,CADmB,EA0BnB;AACEY,EAAAA,MAAM,EAAE;AAAEC,IAAAA,QAAQ,EAAE;AAAZ,GADV;AAEEC,EAAAA,QAAQ,EAAE;AAAED,IAAAA,QAAQ,EAAE;AAAZ;AAFZ,CA1BmB,CAArB,C,CAgCA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA,IAAME,MAAM,GAAGtB,QAAQ,CAACuB,KAAT,CAAe,QAAf,EAAyBrB,YAAzB,CAAf;AAEAsB,MAAM,CAACC,OAAP,GAAiBH,MAAjB","sourcesContent":["const mongoose = require('mongoose');\n// const Tour = require('./tourModel');\n\nconst reviewSchema = new mongoose.Schema(\n  {\n    review: {\n      type: String,\n      required: [true, 'Review can not be empty!']\n    },\n    rating: {\n      type: Number,\n      min: 1,\n      max: 5\n    },\n    createdAt: {\n      type: Date,\n      default: Date.now\n    },\n    tour: {\n      type: mongoose.Schema.ObjectId,\n      ref: 'Tour',\n      required: [true, 'Review must belong to a tour.']\n    },\n    user: {\n      type: mongoose.Schema.ObjectId,\n      ref: 'User',\n      required: [true, 'Review must belong to a user']\n    }\n  },\n  {\n    toJSON: { virtuals: true },\n    toObject: { virtuals: true }\n  }\n);\n\n// reviewSchema.index({ tour: 1, user: 1 }, { unique: true });\n\n// reviewSchema.pre(/^find/, function(next) {\n//   // this.populate({\n//   //   path: 'tour',\n//   //   select: 'name'\n//   // }).populate({\n//   //   path: 'user',\n//   //   select: 'name photo'\n//   // });\n\n//   this.populate({\n//     path: 'user',\n//     select: 'name photo'\n//   });\n//   next();\n// });\n\n// reviewSchema.statics.calcAverageRatings = async function(tourId) {\n//   const stats = await this.aggregate([\n//     {\n//       $match: { tour: tourId }\n//     },\n//     {\n//       $group: {\n//         _id: '$tour',\n//         nRating: { $sum: 1 },\n//         avgRating: { $avg: '$rating' }\n//       }\n//     }\n//   ]);\n//   // console.log(stats);\n\n//   if (stats.length > 0) {\n//     await Tour.findByIdAndUpdate(tourId, {\n//       ratingsQuantity: stats[0].nRating,\n//       ratingsAverage: stats[0].avgRating\n//     });\n//   } else {\n//     await Tour.findByIdAndUpdate(tourId, {\n//       ratingsQuantity: 0,\n//       ratingsAverage: 4.5\n//     });\n//   }\n// };\n\n// reviewSchema.post('save', function() {\n//   // this points to current review\n//   this.constructor.calcAverageRatings(this.tour);\n// });\n\n// // findByIdAndUpdate\n// // findByIdAndDelete\n// reviewSchema.pre(/^findOneAnd/, async function(next) {\n//   this.r = await this.findOne();\n//   // console.log(this.r);\n//   next();\n// });\n\n// reviewSchema.post(/^findOneAnd/, async function() {\n//   // await this.findOne(); does NOT work here, query has already executed\n//   await this.r.constructor.calcAverageRatings(this.r.tour);\n// });\n\nconst Review = mongoose.model('Review', reviewSchema);\n\nmodule.exports = Review;\n"],"file":"reviewSchema.dev.js"}