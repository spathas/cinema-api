{"version":3,"sources":["userModel.js"],"names":["crypto","require","mongoose","bcrypt","userSchema","Schema","name","validator","type","String","email","lowercase","isEmail","required","unique","validate","default","role","minlength","select","el","this","password","passwordChangedAt","Date","passwordResetToken","message","active","Boolean","pre","next","regeneratorRuntime","async","_context","prev","isModified","abrupt","awrap","hash","sent","passwordConfirm","undefined","stop","isNew","now","find","$ne","methods","correctPassword","candidatePassword","userPassword","_context2","compare","changedPasswordAfter","JWTTimestamp","parseInt","createPasswordResetToken","resetToken","randomBytes","toString","createHash","update","digest","console","log","passwordResetExpires","User","model","module","exports"],"mappings":"aAAA,IAAMA,OAASC,QAAQ,UACjBC,SAAWD,QAAQ,YADnBD,UAASC,QAAQ,aAGjBE,OAASF,QAAQ,YAEjBG,WAAaF,SAASG,OAAO,CAHnCC,KAAMC,CAKFC,KAAMC,OAJJN,QAASF,EAAAA,EAAO,4BAEtBS,MAAMN,CACJE,KAAMG,OACJD,SAAMC,EAAAA,EADF,6BAEJR,QAAO,EAHwBU,WAAA,EAKjCD,SAAO,CAAAH,UAAAK,QAAA,iCAELC,MAAAA,OACAC,KAAAA,CACAH,KAAAA,OACAI,KAAAA,CAAAA,OAAWR,SAVoBS,QAAA,QAajCC,SAAM,CACJT,KAAMC,OACNI,SAAO,EAAA,EAAQ,6BACfK,UAAS,EAhBsBC,QAAA,GAmB/BX,gBADQ,CAERK,KAAAA,OACAK,SAAS,EAAE,EAHH,gCAIRC,UAAQ,EAtBuBJ,SAAA,CAyB/BP,UADe,SAAAY,GAEfP,OAAWO,IAAMC,KAAAC,UAEjBP,QAAU,gCAGNQ,kBAASC,KACVC,mBAJOhB,OAKRiB,qBAASF,KALDG,OAAA,CA5BqBnB,KAAAoB,QAoCjCL,SAAAA,EACAE,QAAAA,KAIErB,WAAAyB,IAAS,OAFH,SAAAC,GAAA,OAAAC,mBAAAC,MAAA,SAAAC,GAAA,OAAA,OAAAA,EAAAC,KAAAD,EAAAH,MAAA,KAAA,EAAA,GAAAT,KAAAc,WAAA,YAAA,CAAAF,EAAAH,KAAA,EAAA,MAAA,OAAAG,EAAAG,OAAA,SAAAN,KAAA,KAAA,EAAA,OAAAG,EAAAH,KAAA,EAAAC,mBAAAM,MAOalC,OAAAmC,KAAAjB,KAAAC,SAAA,KAPb,KAAA,EAOaD,KAAAC,SAPbW,EAAAM,KAOalB,KAAAmB,qBAAAC,EAAAX,IAPb,KAAA,EAAA,IAAA,MAAA,OAAAG,EAAAS,SAAA,KAAArB,QAOajB,WAAAyB,IAAA,OAAA,SAAAC,GAarB,IAAKT,KAAKc,WAAW,aAAed,KAAKsB,MAAO,OAAOb,IAEvDT,KAAKE,kBAAoBC,KAAKoB,MAAQ,IAfjBd,MAmBvB1B,WAAWyB,IAAI,QAAS,SAASC,GAd/BT,KAAAwB,KAAA,CAAAlB,OAAKL,CALgBwB,KAAA,KAOrBhB,MAkBF1B,WAAW2C,QAAQC,gBAAkB,SAzBdC,EAAAC,GAyBc,OAAAnB,mBAAAC,MAAA,SAAAmB,GAAA,OAAA,OAAAA,EAAAjB,KAAAiB,EAAArB,MAAA,KAAA,EAAA,OAAAqB,EAAArB,KAAA,EAAAC,mBAAAM,MAzBdlC,OAAAiD,QAAAH,EAAAC,IAyBc,KAAA,EAAA,OAAAC,EAAAf,OAAA,SAAAe,EAAAZ,MAAA,KAAA,EAAA,IAAA,MAAA,OAAAY,EAAAT,WAzBdtC,WAAvB2C,QAAAM,qBAAA,SAAAC,GAYAlD,QAAAA,KAAWyB,mBAQTyB,EAPqBC,SAErBlC,KAAKE,kBAAoBC,UAAa,IAClC,KAOLpB,WAJD2C,QAAAS,yBAAA,WA4BE,IAAMC,EAAazD,OAAO0D,YAAY,IAAIC,SAAS,OAWnD,OAjCmCtC,KAAAI,mBAAAzB,OAAA4D,WAAA,UAAAC,OAAAJ,GAAAK,OAAA,OAAAC,QAAAC,IAAA,CAAAP,WAAAA,GAAApC,KAAAI,oBAAAJ,KAAA4C,qBAAAzC,KAAAoB,MAAA,IAiC5Ba,GAjC4B,IAAAS,KAAAhE,SAAAiE,MAAA,OAAA/D,YAAAgE,OAAAC,QAAAH","file":"userModel.min.js","sourcesContent":["const crypto = require('crypto');\nconst mongoose = require('mongoose');\nconst validator = require('validator');\nconst bcrypt = require('bcryptjs');\n\nconst userSchema = mongoose.Schema({\n  name: {\n    type: String,\n    require: [true, 'A user must have a name']\n  },\n  email: {\n    type: String,\n    required: [true, 'Please provide your email'],\n    unique: true,\n    lowercase: true,\n    validate: [validator.isEmail, 'Please provide a valid email']\n  },\n  photo: String,\n  role: {\n    type: String,\n    enum: ['user', 'admin'],\n    default: 'user'\n  },\n  password: {\n    type: String,\n    required: [true, 'Please provide a password'],\n    minlength: 8,\n    select: false\n  },\n  passwordConfirm: {\n    type: String,\n    required: [true, 'Please confirm your password'],\n    minlength: 8,\n    validate: {\n      // This only works on CREATE and SAVE!!!\n      validator: function(el) {\n        return el === this.password;\n      },\n      message: 'Passwords are not the same!'\n    }\n  },\n  passwordChangedAt: Date,\n  passwordResetToken: String,\n  passwordResetExpires: Date,\n  active: {\n    type: Boolean,\n    default: true,\n    select: false\n  }\n});\n\nuserSchema.pre('save', async function(next) {\n  // Only run this function if password was actually modified\n  if (!this.isModified('password')) return next();\n\n  // Hash the password with cost of 12\n  this.password = await bcrypt.hash(this.password, 12);\n\n  // Delete passwordConfirm field\n  this.passwordConfirm = undefined;\n  next();\n});\n\nuserSchema.pre('save', function(next) {\n  if (!this.isModified('password') || this.isNew) return next();\n\n  this.passwordChangedAt = Date.now() - 1000;\n  next();\n});\n\nuserSchema.pre(/^find/, function(next) {\n  // this points to the current query\n  this.find({ active: { $ne: false } });\n  next();\n});\n\nuserSchema.methods.correctPassword = async function(\n  candidatePassword,\n  userPassword\n) {\n  return await bcrypt.compare(candidatePassword, userPassword);\n};\n\nuserSchema.methods.changedPasswordAfter = function(JWTTimestamp) {\n  if (this.passwordChangedAt) {\n    const changedTimestamp = parseInt(\n      this.passwordChangedAt.getTime() / 1000,\n      10\n    );\n\n    return JWTTimestamp < changedTimestamp;\n  }\n\n  // False means NOT changed\n  return false;\n};\n\nuserSchema.methods.createPasswordResetToken = function() {\n  const resetToken = crypto.randomBytes(32).toString('hex');\n\n  this.passwordResetToken = crypto\n    .createHash('sha256')\n    .update(resetToken)\n    .digest('hex');\n\n  console.log({ resetToken }, this.passwordResetToken);\n\n  this.passwordResetExpires = Date.now() + 10 * 60 * 1000;\n\n  return resetToken;\n};\n\nconst User = mongoose.model('User', userSchema);\n\nmodule.exports = User;\n"]}