{"version":3,"sources":["userModel.js"],"names":["crypto","require","mongoose","validator","bcrypt","userSchema","Schema","name","type","String","email","required","unique","lowercase","validate","isEmail","photo","role","password","minlength","select","passwordConfirm","el","message","passwordChangedAt","Date","passwordResetToken","passwordResetExpires","active","Boolean","pre","next","isModified","hash","undefined","isNew","now","find","$ne","methods","correctPassword","candidatePassword","userPassword","compare","changedPasswordAfter","JWTTimestamp","changedTimestamp","parseInt","getTime","createPasswordResetToken","resetToken","randomBytes","toString","createHash","update","digest","console","log","User","model","module","exports"],"mappings":"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","sourcesContent":["const crypto = require('crypto');\nconst mongoose = require('mongoose');\nconst validator = require('validator');\nconst bcrypt = require('bcryptjs');\n\nconst userSchema = mongoose.Schema({\n  name: {\n    type: String,\n    require: [true, 'A user must have a name']\n  },\n  email: {\n    type: String,\n    required: [true, 'Please provide your email'],\n    unique: true,\n    lowercase: true,\n    validate: [validator.isEmail, 'Please provide a valid email']\n  },\n  photo: String,\n  role: {\n    type: String,\n    enum: ['user', 'admin'],\n    default: 'user'\n  },\n  password: {\n    type: String,\n    required: [true, 'Please provide a password'],\n    minlength: 8,\n    select: false\n  },\n  passwordConfirm: {\n    type: String,\n    required: [true, 'Please confirm your password'],\n    minlength: 8,\n    validate: {\n      // This only works on CREATE and SAVE!!!\n      validator: function(el) {\n        return el === this.password;\n      },\n      message: 'Passwords are not the same!'\n    }\n  },\n  passwordChangedAt: Date,\n  passwordResetToken: String,\n  passwordResetExpires: Date,\n  active: {\n    type: Boolean,\n    default: true,\n    select: false\n  }\n});\n\nuserSchema.pre('save', async function(next) {\n  // Only run this function if password was actually modified\n  if (!this.isModified('password')) return next();\n\n  // Hash the password with cost of 12\n  this.password = await bcrypt.hash(this.password, 12);\n\n  // Delete passwordConfirm field\n  this.passwordConfirm = undefined;\n  next();\n});\n\nuserSchema.pre('save', function(next) {\n  if (!this.isModified('password') || this.isNew) return next();\n\n  this.passwordChangedAt = Date.now() - 1000;\n  next();\n});\n\nuserSchema.pre(/^find/, function(next) {\n  // this points to the current query\n  this.find({ active: { $ne: false } });\n  next();\n});\n\nuserSchema.methods.correctPassword = async function(\n  candidatePassword,\n  userPassword\n) {\n  return await bcrypt.compare(candidatePassword, userPassword);\n};\n\nuserSchema.methods.changedPasswordAfter = function(JWTTimestamp) {\n  if (this.passwordChangedAt) {\n    const changedTimestamp = parseInt(\n      this.passwordChangedAt.getTime() / 1000,\n      10\n    );\n\n    return JWTTimestamp < changedTimestamp;\n  }\n\n  // False means NOT changed\n  return false;\n};\n\nuserSchema.methods.createPasswordResetToken = function() {\n  const resetToken = crypto.randomBytes(32).toString('hex');\n\n  this.passwordResetToken = crypto\n    .createHash('sha256')\n    .update(resetToken)\n    .digest('hex');\n\n  console.log({ resetToken }, this.passwordResetToken);\n\n  this.passwordResetExpires = Date.now() + 10 * 60 * 1000;\n\n  return resetToken;\n};\n\nconst User = mongoose.model('User', userSchema);\n\nmodule.exports = User;\n"],"file":"userModel.dev.js"}