{"version":3,"sources":["reviewModel.js"],"names":["mongoose","require","Title","reviewSchema","Schema","review","required","type","Number","rating","max","Date","createdAt","now","title","ObjectId","ref","toJSON","virtuals","index","user","unique","pre","next","populate","calcAverageRatings","titleId","stats","regeneratorRuntime","async","_context","prev","awrap","this","aggregate","select","$match","$group","statics","nRating","$sum","avgRating","$avg","sent","length","ratingsAverage","_id","stop","tour","post","_context2","findOne","r","_context3","constructor","Review","model","module","exports"],"mappings":"aAAA,IAAMA,SAAWC,QAAQ,YACnBC,MAAQD,QAAQ,gBAEhBE,aAAe,IAAIH,SAASI,OAFlC,CAIIC,OAAQ,CAFNF,KAAAA,OAEFE,SAAQ,EAAA,EAAA,6BAENC,OAAQ,CAHZC,KAAAC,OAKEC,IAAQ,EACNF,IAAMC,GAENE,UAAK,CARTH,KAAAI,KAUEC,QAAWD,KAAAE,KAETC,MAAA,CAZJP,KAAAP,SAAAI,OAAAW,SAcED,IAAO,QACLP,SAAMP,EAAAA,EAASI,yCAEfE,KAAAA,CAjBJC,KAAAP,SAAAI,OAAAW,SAmBMC,IAAE,OACJT,SAAMP,EAAAA,EAASI,kCADX,CAMRa,OAAA,CAAAC,UAAA,GACED,SAAQ,CAAAC,UAAA,KACIA,aAAQC,MAAE,CAAAL,MAAA,EAAAM,KAAA,GAAA,CAAAC,QAAA,IAFxBlB,aA1BFmB,IAAA,QAAA,SAAAC,GAgCApB,KAAAA,SAAagB,CAAQL,KAAF,OAAYM,OAAM,eAAOC,MAG1ClB,aAAKqB,QAASC,mBAAA,SAAAC,GAAA,IAAAC,EAAA,OAAAC,mBAAAC,MAAA,SAAAC,GAAA,OAAA,OAAAA,EAAAC,KAAAD,EAAAP,MAAA,KAAA,EAAA,OAAAO,EAAAP,KAAA,EAAAK,mBAAAI,MAAAC,KAAAC,UAAA,CAEZC,CAFFC,OAAA,CAAAtB,MAAAY,IADF,CAcMW,OAAQ,CANdlC,IAAamC,SAA6BC,QAAA,CAAAC,KAAA,GAAAC,UAAA,CAAAC,KAAA,gBAP1B,KAAA,EAAA,GAO0B,GANlCf,EADQG,EAAAa,MAO0BC,OAP1B,OAAAd,EAAAP,KAAA,EAAAK,mBAAAI,MAUVI,MAAAA,kBAAQV,EAAA,CAAEZ,gBAAOY,EAAAA,GAAAA,QAATmB,eAAAlB,EAAA,GAAAc,aAVEX,EAAAP,KAAA,EAAA,MAAA,KAAA,EAAAO,EAAAP,KAAA,GAAA,MAAA,KAAA,EAAA,OAAAO,EAAAP,KAAA,GAAAK,mBAAAI,MAcRc,MAAAA,kBADMpB,EAAA,CAENa,gBAAS,EAAEC,eAAM,OAfT,KAAA,GAAA,IAAA,MAAA,OAAAV,EAAAiB,SAAA,KAAAd,OAaF9B,aAAAgB,MAAA,CAAA6B,KAAA,EAAA5B,KAAA,GAAA,CAAAC,QAAA,IAuBdlB,aAAa8C,KAAK,OAAQ,WA5BlBtB,KAAAA,YADkCF,mBAAAQ,KAAAnB,SAAAX,aAAAmB,IAAA,cAAA,SAAAC,GAAA,OAAAK,mBAAAC,MAAA,SAAAqB,GAAA,OAAA,OAAAA,EAAAnB,KAAAmB,EAAA3B,MAAA,KAAA,EAAA,OAAA2B,EAAA3B,KAAA,EAAAK,mBAAAI,MAqCzBC,KAAKkB,WArCoB,KAAA,EAqCxClB,KAAKmB,EArCmCF,EAAAP,KAAApB,IAAA,KAAA,EAAA,IAAA,MAAA,OAAA2B,EAAAH,SAAA,KAAAd,QAeC9B,aAfD8C,KAAA,cAAA,WAAA,OAAArB,mBAAAC,MAAA,SAAAwB,GAAA,OAAA,OAAAA,EAAAtB,KAAAsB,EAAA9B,MAAA,KAAA,EAAA,OAAA8B,EAAA9B,KAAA,EAAAK,mBAAAI,MAAAC,KAAAmB,EAAAE,YAAA7B,mBAAAQ,KAAAmB,EAAAtC,QAAA,KAAA,EAAA,IAAA,MAAA,OAAAuC,EAAAN,SAAA,KAAAd,QA+C1C,IAAMsB,OAASvD,SAASwD,MAAM,SAAUrD,cA/CEsD,OAAAC,QAAAH","file":"reviewModel.min.js","sourcesContent":["const mongoose = require('mongoose');\nconst Title = require('./titleModel');\n\nconst reviewSchema = new mongoose.Schema(\n  {\n    review: {\n      type: String,\n      required: [true, 'Review can not be empty!']\n    },\n    rating: {\n      type: Number,\n      min: 1,\n      max: 5\n    },\n    createdAt: {\n      type: Date,\n      default: Date.now\n    },\n    title: {\n      type: mongoose.Schema.ObjectId,\n      ref: 'Title',\n      required: [true, 'Review must belong to a movie title.']\n    },\n    user: {\n      type: mongoose.Schema.ObjectId,\n      ref: 'User',\n      required: [true, 'Review must belong to a user']\n    }\n  },\n  {\n    toJSON: { virtuals: true },\n    toObject: { virtuals: true }\n  }\n);\n\nreviewSchema.index({ title: 1, user: 1 }, { unique: true });\n\nreviewSchema.pre(/^find/, function(next) {\n  this.populate({\n    path: 'user',\n    select: 'name photo'\n  });\n  next();\n});\n\nreviewSchema.statics.calcAverageRatings = async function(titleId) {\n  const stats = await this.aggregate([\n    {\n      $match: { title: titleId }\n    },\n    {\n      $group: {\n        _id: '$title',\n        nRating: { $sum: 1 },\n        avgRating: { $avg: '$rating' }\n      }\n    }\n  ]);\n\n  if (stats.length > 0) {\n    await Title.findByIdAndUpdate(titleId, {\n      ratingsQuantity: stats[0].nRating,\n      ratingsAverage: stats[0].avgRating\n    });\n  } else {\n    await Title.findByIdAndUpdate(titleId, {\n      ratingsQuantity: 0,\n      ratingsAverage: 4.5\n    });\n  }\n};\n\nreviewSchema.index({ tour: 1, user: 1 }, { unique: true });\n\nreviewSchema.post('save', function() {\n  // this points to current review\n  this.constructor.calcAverageRatings(this.title);\n});\n\n// findByIdAndUpdate\n// findByIdAndDelete\nreviewSchema.pre(/^findOneAnd/, async function(next) {\n  this.r = await this.findOne();\n  // console.log(this.r);\n  next();\n});\n\nreviewSchema.post(/^findOneAnd/, async function() {\n  // await this.findOne(); does NOT work here, query has already executed.\n  await this.r.constructor.calcAverageRatings(this.r.title);\n});\n\nconst Review = mongoose.model('Review', reviewSchema);\n\nmodule.exports = Review;\n"]}