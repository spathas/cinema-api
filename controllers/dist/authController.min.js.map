{"version":3,"sources":["authController.js"],"names":["crypto","require","promisify","User","catchAsync","AppError","signToken","id","jwt","process","env","JWT_SECRET","expiresIn","JWT_EXPIRES_IN","createAndSendToken","user","statusCode","res","_id","expires","sign","Date","NODE_ENV","cookieOptions","secure","httpOnly","json","status","token","req","newUser","regeneratorRuntime","async","_context","prev","next","awrap","name","body","email","password","exports","passwordConfirm","role","sent","stop","login","_req$body","_context2","abrupt","findOne","select","t0","correctPassword","decoded","currentUser","_context3","headers","authorization","startsWith","split","verify","findById","changedPasswordAfter","iat","Error","restrictTo","_len","arguments","length","roles","Array","_key","includes","forgotPassword","resetToken","resetURL","message","_context4","protect","save","validateBeforeSave","concat","protocol","get","sendEmail","subject","passwordResetToken","undefined","resetPassword","hashedToken","_context5","createHash","update","params","digest","passwordResetExpires","$gt","now","_context6","newPassword"],"mappings":"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","file":"authController.min.js","sourcesContent":["const crypto = require('crypto');\nconst { promisify } = require('util');\nconst jwt = require('jsonwebtoken');\nconst User = require('../models/userModel');\nconst catchAsync = require('../utils/catchAsync');\nconst sendEmail = require('../utils/email');\nconst AppError = require('../utils/appError');\n\nconst signToken = id => {\n  return jwt.sign({ id }, process.env.JWT_SECRET, {\n    expiresIn: process.env.JWT_EXPIRES_IN\n  });\n};\n\nconst createAndSendToken = (user, statusCode, res) => {\n  const token = signToken(user._id);\n\n  const cookieOptions = {\n    expires: new Date(\n      Date.now() + process.env.JWT_COOKIE_EXPIRES_IN * 24 * 60 * 60 * 1000\n    ),\n    httpOnly: true\n  };\n\n  if (process.env.NODE_ENV === 'production') cookieOptions.secure = true;\n  res.cookie('jwt', token, cookieOptions);\n\n  user.password = undefined;\n\n  res.status(statusCode).json({\n    status: 'success',\n    token,\n    user\n  });\n};\n\nexports.signup = catchAsync(async (req, res, next) => {\n  const newUser = await User.create({\n    name: req.body.name,\n    email: req.body.email,\n    password: req.body.password,\n    passwordConfirm: req.body.passwordConfirm,\n    role: req.body.role\n  });\n  createAndSendToken(newUser, 201, res);\n});\n\nexports.login = catchAsync(async (req, res, next) => {\n  const { email, password } = req.body;\n\n  // 1) Check if email and password are existing.\n  if (!email || !password) {\n    return next(new AppError('Please enter a valid email and password', 400));\n  }\n\n  // 2) Check if User exists and password is valid.\n  const user = await User.findOne({ email }).select('+password');\n  //{email} = email: email ---- '+password' to detour the non selected command.\n\n  if (!user || !(await user.correctPassword(password, user.password))) {\n    return next(new AppError('Incorrect email or password', 401));\n  }\n\n  // 3) If everything is OK, sent token to client.\n  createAndSendToken(user, 200, res);\n});\n\nexports.protect = catchAsync(async (req, res, next) => {\n  // 1) Get the token and check if it exists.\n  let token;\n  if (\n    req.headers.authorization &&\n    req.headers.authorization.startsWith('Bearer')\n  ) {\n    token = req.headers.authorization.split(' ')[1];\n  }\n\n  if (!token) {\n    return next(new AppError('Please log in to get access.', 401));\n  }\n\n  // 2) Verification token.\n  const decoded = await promisify(jwt.verify)(token, process.env.JWT_SECRET);\n\n  // 3) Check if user still exists.\n  const currentUser = await User.findById(decoded.id);\n\n  if (!currentUser) {\n    return next(new AppError('User does not exist.', 401));\n  }\n  // 4) Check if user changed password after the token was issued.\n  if (currentUser.changedPasswordAfter(decoded.iat)) {\n    return next(\n      new Error('User recently changed password. Please log in again', 401)\n    );\n  }\n\n  // Access to protected route.\n  req.user = currentUser;\n  next();\n});\n\nexports.restrictTo = (...roles) => {\n  return (req, res, next) => {\n    // Roles ['admin', 'lead-guid']\n    if (!roles.includes(req.user.role)) {\n      return next(\n        new AppError('You do not have permission to perform this action.', 403)\n      );\n    }\n\n    next();\n  };\n};\n\nexports.forgotPassword = catchAsync(async (req, res, next) => {\n  // 1) Get user based on POSTed email\n  const user = await User.findOne({ email: req.body.email });\n  if (!user) {\n    return next(new AppError('There is no user with email address.', 404));\n  }\n\n  // 2) Generate the random reset token\n  const resetToken = user.createPasswordResetToken();\n  await user.save({ validateBeforeSave: false });\n\n  // 3) Send it to user's email\n  const resetURL = `${req.protocol}://${req.get(\n    'host'\n  )}/api/v1/users/resetPassword/${resetToken}`;\n\n  const message = `Forgot your password? Submit a PATCH request with your new password and passwordConfirm to: ${resetURL}.\\nIf you didn't forget your password, please ignore this email!`;\n\n  try {\n    await sendEmail({\n      email: user.email,\n      subject: 'Your password reset token (valid for 10 min)',\n      message\n    });\n\n    res.status(200).json({\n      status: 'success',\n      message: 'Token sent to email!'\n    });\n  } catch (err) {\n    user.passwordResetToken = undefined;\n    user.passwordResetExpires = undefined;\n    await user.save({ validateBeforeSave: false });\n\n    return next(\n      new AppError('There was an error sending the email. Try again later!'),\n      500\n    );\n  }\n});\n\nexports.resetPassword = catchAsync(async (req, res, next) => {\n  // 1) Get user based on the token.\n  const hashedToken = crypto\n    .createHash('sha256')\n    .update(req.params.token)\n    .digest('hex');\n\n  const user = await User.findOne({\n    passwordResetToken: hashedToken,\n    passwordResetExpires: { $gt: Date.now() }\n  });\n  // 2) If token has not expired, and there is a user, set the new password.\n  if (!user) {\n    return next(new AppError('Token is invalid or has expired', 400));\n  }\n  user.password = req.body.password;\n  user.passwordConfirm = req.body.passwordConfirm;\n  user.passwordResetToken = undefined;\n  user.passwordResetExpires = undefined;\n  await user.save();\n  // 3) Update changedPasswordAt property for the user.\n  // 4) Log the user in, send JWT.\n  createAndSendToken(user, 200, res);\n});\n\nexports.updatePassword = catchAsync(async (req, res, next) => {\n  // 1) Get user from collection.\n  const user = await User.findById(req.user.id).select('+password');\n  // console.log(user);\n  if (!user) {\n    return next(\n      new AppError('Can authorize your account. Please log in again.', 404)\n    );\n  }\n  // 2) Check if POSTed current password is correct.\n  if (!(await user.correctPassword(req.body.password, user.password))) {\n    return next(new AppError('Incorrect password', 401));\n  }\n  // 3) If so, update password.\n  user.password = req.body.newPassword;\n  user.passwordConfirm = req.body.newPasswordConfirm;\n  await user.save();\n  // 4) Log user in, send JWT.\n  createAndSendToken(user, 200, res);\n});\n"]}